---
title: 算法题
date: 2019-06-29 16:41:28
tags:
---
## 1. 
Description

给出 2 * n + 1个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。

Example
```
样例 1:

输入：[1,1,2,2,3,4,4]
输出：3
解释：
仅3出现一次
样例 2:

输入：[0,0,1]
输出：1
解释：
仅1出现一次
Challenge
一次遍历，常数级的额外空间复杂度

Notice
n≤100
```

```js
/**
 * @param A: An integer array
 * @return: An integer
 */
const singleNumber = function (A) {
    let arr = []
    let str = A.toString().replace(/,/g, "")
    let len = str.length
    if (len > 1) {
    for (let i = 0; i < len; i++){
        if(str.split(str[i]).length - 1 == 1) {
            return parseInt(str[i])
        }
    }
    }else {
        return A[0]
    }
}
```

## 2. 设计一个算法，计算出n阶乘中尾部零的个数
Description

Write an algorithm which computes the number of trailing zeros in n factorial.

```
Example
Example 1:
	Input:  11
	Output: 2
	
	Explanation: 
	11! = 39916800, so the output should be 2

Example 2:
	Input:  5
	Output: 1
	
	Explanation: 
	5! = 120, so the output should be 1.
```

思路：
可以将每个数拆分成其素因子的乘积，可以发现，0是由2*5产生的，而5的数量一定小于2的数量，因此5的个数决定了结尾0的个数。

只要计算n的阶乘中，5这个素因子出现多少次即可。

代码

```js
/**
 * @param n: A long integer
 * @return: An integer, denote the number of trailing zeros in n!
 */
const trailingZeros = function (n) {
    var sum = 0;
    while (n !== 0) {
        sum += Math.floor(n / 5);
        n = Math.floor(n / 5);
    }
    return sum;
} 
```

## 3. 将两个给定的排序升序整数数组A和B合并为一个新的排序整数数组。

Description

Merge two given sorted ascending integer array A and B into a new sorted integer array.

Example
```
Example 1:

Input:  A=[1], B=[1]
Output: [1,1]	
Explanation:  return array merged.
Example 2:

Input:  A=[1,2,3,4], B=[2,4,5,6]
Output: [1,2,2,3,4,4,5,6]	
Explanation: return array merged.
```

Challenge

How can you optimize your algorithm if one array is very large and the other is very small?

思路：

使用两个指针分别对数组从小到大遍历，每次取二者中较小的放在新数组中。
直到某个指针先到结尾，另一个数组中剩余的数字直接放在新数组后面。

时间复杂度O(n)

代码：

```js
/**
 * @param A: sorted integer array A
 * @param B: sorted integer array B
 * @return: A new sorted integer array
 */
const mergeSortedArray = function (A, B) {
    var i, j
    let arr = []
    let aLen = A.length
    let bLen = B.length
    for (i = 0, j = 0; i < aLen && j < bLen;) {
        if (A[i] < B[j]) {
            arr.push(A[i++])
        } else {
            arr.push(B[j++])
        }
    }
    while(i < aLen) {
        arr.push(A[i++])
    }
    
    while(j < bLen) {
        arr.push(B[j++])
    }
    
    return arr
}
```
